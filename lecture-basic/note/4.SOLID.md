## SOLID

객체지향프로그래밍에서 가장 중요한 것은 ***다형성***

객체지향프로그래밍의 원칙

-   SRP(단일책임 원칙)
-   OCP(개방폐쇄의 원칙)
-   LSP(리스코프 치환 원칙)
-   ISP(인터페이스 분리 원칙)
-   DIP(의존관계 역전 원칙)



**1. ** **SRP** **단일 책임 원칙** **Single responsibility principle**

-   한 클래스는 하나의 책임만 가져야 한다. 

-   하나의 책임이라는 것은 모호하다.

    -   클 수 있고, 작을 수 있다.
    -   문맥과 상황에 따라 다르다.

-    **중요한 기준은 변경**이다. 변경이 있을 때 파급 효과가 적으면 단일 책임 원칙을 잘 따른 것 

    예) UI 변경, 객체의 생성과 사용을 분리



**2.** **OCP** **개방-폐쇄 원칙** **Open/closed principle**

-   소프트웨어 요소는 **확장에는 열려** 있으나 **변경에는 닫혀** 있어야 한다.

    ***-> 변경하는 클래스의 확장(기능 추가, 변경)은 용이하되, 변경 클래스를 의존하는 클래스(클라이언트)의 변경은 닫혀있어야 한다.***

-   이런 거짓말 같은 말이? 

-   확장을 하려면, 당연히 기존 코드를 변경? 

-   **다형성**을 활용해보자

-   인터페이스를 구현한 새로운 클래스를 하나 만들어서 새로운 기능을 구현 지금까지 배운 역할(인터페이스)과 구현의 분리를 생각해보자

    ***-> 클라이언트가 인터페이스만을 의존하고 있다면, 구현체만을 변경함으로써 OCP 원칙을 만족시킬 수 있다!***

    

**5. DIP 의존관계 역전 원칙 Dependency inversion principle**

-   프로그래머는 “추상화에 의존해야지, 구체화에 의존하면 안된다.” 

-   의존성 주입은 이 원칙 을 따르는 방법 중 하나다.

-   쉽게 이야기해서 구현 클래스에 의존하지 말고, 인터페이스에 의존하라는 뜻

-   앞에서 이야기한 **역할(Role)에 의존하게 해야 한다는 것과 같다.** 객체 세상도 클라이언트 가 인터페이스에 의존해야 유연하게 구현체를 변경할 수 있다! 구현체에 의존하게 되면 변경이 아주 어려워진다.

-   그런데 OCP에서 설명한 MemberService는 인터페이스에 의존하지만, 구현 클래스도 동시에 의존한다.

-   MemberService 클라이언트가 구현 클래스를 직접 선택

    ```java
    MemberRepository m = new MemoryMemberRepository(); 
    ```

-   **DIP** **위반**



### 정리

-   객체 지향의 핵심은 다형성

-   다형성 만으로는 쉽게 부품을 갈아 끼우듯이 개발할 수 없다.

-   다형성 만으로는 구현 객체를 변경할 때 클라이언트 코드도 함께 변경된다.

    -> 어떻게 하든 구현체를 변경하는 코드는 들어가야한다~

-   **다형성 만으로는 OCP, DIP를 지킬 수 없다.**

-   뭔가 더 필요하다.

    -> 스프링이 이 역할을 해주지 않을까??



스프링의 역할?????

-   스프링은 다임 기술로 다형성 + OCP, DIP를 가능하게 지원
    -   DI
    -   DI 컨테이너 제공
    -   확장에는 열려있고, 변경에는 닫혀있으며, 클라이언트가 인터페이스만을 의존하여 구현될 수 있도록 해준다.
-   클라이언트 코드 변경 없이 기능 확장할 수 있음
-   쉽게 부품 교체하듯 개발



정리

-   이상적인 객체 지향 코드는 역할(인터페이스)와 배역(구현)을 분리하여 코딩하는 것

-   역할/구현을 분리한다면 역할에 대한 구현을 변경하면서 기능을 확장시킬 수 있다.

-   그러나 인터페이스는 추상화의 비용이 발생한다(단점)

    -> 구체적으로 말하면 개발자가 구현 클래스의 내용을 한번 더 찾아서 봐야하는 비용이 발생

    -> 인터페이스, 구현체 코드도 증가

-   그래서 장점(OCP)이 단점을 넘어섰을 때 도입하는 것이 좋다

-   기능을 확장할 가능성이 없다면, 구현체 클래스를 직접 사용하고 향후 꼭 필요할 때 리팩터링을 통해서 인터페이스를 도입하는 것도 방법이 될 수 있다.